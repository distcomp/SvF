SELECT: t, xNoisy1 as x1, yNoisy1 as y1, zNoisy1 as z1, xNoisy2 as x2, yNoisy2 as y2, zNoisy2 as z2, xNoisy3 as x3, yNoisy3 as y3, zNoisy3 as z3 \
	FROM "3Body3D.dat"

SET: t = [ , , 0.01]  # временная ось
SET: r = [0.5, 5.0, 0.1]  # множество для расстояний

# Положения планет как функции времени (3D)
VAR: x1(t)  # планета 1, координата x
     y1(t)  # планета 1, координата y
     z1(t)  # планета 1, координата z
     x2(t)  # планета 2, координата x
     y2(t)  # планета 2, координата y
     z2(t)  # планета 2, координата z
     x3(t)  # планета 3, координата x
     y3(t)  # планета 3, координата y
     z3(t)  # планета 3, координата z

# Искомые параметры и функции
#VAR: G_const; G_const > 0  # гравитационная постоянная
G_const = 1
VAR: m1 > 0  # масса планеты 1
     m2 > 0  # масса планеты 2
     m3 > 0  # масса планеты 3
     fr(r) = Polynome(8); >0; fr(1.) = 1.; fr'<0  # неизвестная функция зависимости силы от расстояния

# Вспомогательные функции для расстояний
VAR: r12(t) = sqrt((x2(t) - x1)^2 + (y2 - y1)^2 + (z2 - z1)^2); ArgNorm=False
     r13(t) = sqrt((x3 - x1)^2 + (y3 - y1)^2 + (z3 - z1)^2); ArgNorm=False
     r23(t) = sqrt((x3 - x2)^2 + (y3 - y2)^2 + (z3 - z2)^2); ArgNorm=False

# Уравнения движения с неизвестной функцией fr(r)
# Для планеты 1
EQ: x1'' = G_const * m2 * fr(r12(t)) * (x2 - x1)/r12(t) + \
           G_const * m3 * fr(r13(t)) * (x3 - x1)/r13(t)

EQ: y1'' = G_const * m2 * fr(r12(t)) * (y2 - y1)/r12(t) + \
           G_const * m3 * fr(r13(t)) * (y3 - y1)/r13(t)

EQ: z1'' = G_const * m2 * fr(r12(t)) * (z2 - z1)/r12(t) + \
           G_const * m3 * fr(r13(t)) * (z3 - z1)/r13(t)

# Для планеты 2
EQ: x2'' = G_const * m1 * fr(r12(t)) * (x1 - x2)/r12(t) + \
           G_const * m3 * fr(r23(t)) * (x3 - x2)/r23(t)

EQ: y2'' = G_const * m1 * fr(r12(t)) * (y1 - y2)/r12(t) + \
           G_const * m3 * fr(r23(t)) * (y3 - y2)/r23(t)

EQ: z2'' = G_const * m1 * fr(r12(t)) * (z1 - z2)/r12(t) + \
           G_const * m3 * fr(r23(t)) * (z3 - z2)/r23(t)

# Для планеты 3  
EQ: x3'' = G_const * m1 * fr(r13(t)) * (x1 - x3)/r13(t) + \
           G_const * m2 * fr(r23(t)) * (x2 - x3)/r23(t)

EQ: y3'' = G_const * m1 * fr(r13(t)) * (y1 - y3)/r13(t) + \
           G_const * m2 * fr(r23(t)) * (y2 - y3)/r23(t)

EQ: z3'' = G_const * m1 * fr(r13(t)) * (z1 - z3)/r13(t) + \
           G_const * m2 * fr(r23(t)) * (z2 - z3)/r23(t)

CV:   NumOfSets=5
RUN:  MaxIter=0;  RunMode = 'L&S'

# Критерий: близость траекторий + сложность траекторий и функции fr
OBJ: x1.MSD() + y1.MSD() + z1.MSD() + \
     x2.MSD() + y2.MSD() + z2.MSD() + \
     x3.MSD() + y3.MSD() + z3.MSD() + \
     x1.Complexity(Penal[0]) + y1.Complexity(Penal[1]) + z1.Complexity(Penal[2]) + \
     x2.Complexity(Penal[3]) + y2.Complexity(Penal[4]) + z2.Complexity(Penal[5]) + \
     x3.Complexity(Penal[6]) + y3.Complexity(Penal[7]) + z3.Complexity(Penal[8]) + \
     fr.Complexity(Penal[9])

PLOT: x1 + y1 + z1
      x2 + y2 + z2
      x3 + y3 + z3


PARAM: rev_fr (r);
for nr in r.NodS : rev_fr.grd[nr] = 1/(r.Val[nr])**2

PLOT: rev_fr,label=1/r/r + fr,c=g,file=1_r_r

EoF

